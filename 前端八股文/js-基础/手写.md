### 1. call
```js
const getType = (value) =>
    Object.prototype.toString.call(value).match(/(?<=\s)[a-zA-Z]+/)[0];       // 获取类型

function test(c) {
    console.log('test fun --- ', this, c);
}
let aa = { a: 1 },
    bb = { a: 2 };
test.call([], 8, 9);

// 注意,这里定义函数的时候 需要这么写,不能写箭头函数
Function.prototype.myCall = function (_this, ...args) {
    // 这里的 this 指向的是 test 函数, _this 是 call 的第一个参数,args 是一个数组,用来存储后续其他的参数
    // console.log(this,_this,args);

    // 当传入 null,或者 undefined 的时候,默认指向 window    
    _this = _this ?? window; 
    if (!['Object', 'Array'].includes(_this)) { // call 的行为如此 , 对于对象,和数组,就直接执行,否则 转化为 包装器类型  
        _this = new Object(_this); 
    }
    const key = Symbol(); // 这个值是唯一的
    _this[key] = this; // 在_this 上定义该函数
    const result = _this[key](...args);  // 执行该函数
    delete _this[key];  // 删除上面定义的这个函数
    return result;     // 返回结果
};

// 这里有个小问题,test 函数执行时,打印的结果中,会有 Symbol
test.myCall([], 8, 9);
```

#### 浅拷贝
```js
const o = { a: 1, b: 2, c: 3, d: { e: 1 } };
function copy(obj) {
  if (typeof obj !== "object" || !obj) {
    return;
  }
  const result = Array.isArray(obj) ? [] : {};
  for (let [k, v] of Object.entries(obj)) {
    result[k] = v;
  }
  return result;
}

const res = copy(o);
console.assert(res.d === o.d); // 这个是浅拷贝,所以结果是 true

```

#### 深拷贝  (不考虑 Date,Regexp 类型,以及循环引用)

```ts
type CommonObj = Record<string | number, any>;
const { stringify: str } = JSON;
const o: CommonObj = {
    a: 1,
    b: 2,
    c: 3,
    d: { e: 1, f: { g: 1, h: 2 } },
};

function deepCopy<T>(obj: T) {
    if (typeof obj !== 'object' || !obj) {
        return obj;
    }
    const result: CommonObj = Array.isArray(obj) ? [] : {};
    for (let [k, v] of Object.entries(obj)) {
        if (Array.isArray(v)) {
            result[k] = deepCopy(v);
        } else if (typeof v === 'object') {
            result[k] = deepCopy(v);
        } else {
            result[k] = v;
        }
    }
    return result;
}

const res = deepCopy(o);
console.log(str(res) === str(o));

```


#### 深拷贝,处理复杂情况(循环引用,特殊对象)
```js
const o = {
    a: 1,
    b: 2,
    c: 3,
    d: { e: 1, f: { g: 1, h: 2 } },
    dd: new Date(),
    ee: /^(ab+.*123)$/,
};
const isObject = (value) =>
    ['Function', 'Object'].includes(
        Object.prototype.toString.call(value).slice(8, -1)
    );
function deepCopy(value, map = new Map()) {
    // 先判断循环引用
    if (map.get(value)) {
        return value;
    }
    // 获取构造函数
    const constructor = value.constructor;
    // 判断构造函数名称,对于这两种类型,返回特定结果
    if (/^(RegExp|Date)$/.test(constructor.name)) {
        return new constructor(value);
    }
    const result = Array.isArray(value) ? [] : {};
    if (!isObject(value)) {
        return value;
    }
    for (let [k, v] of Object.entries(value)) {
        map.set(value, true);
        result[k] = deepCopy(v, map);
    }
    return result;
}
const res = deepCopy(o);
console.log(res);
```