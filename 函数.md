#### 声明和表达式
函数声明会提升..并且优先级比变量声明的优先级高.但是函数表达式的不会提升;以下例子会出问题:  
```js
test();
var test=function(){}   //test is not a function.
```
### 递归
函数内部调用自身,例子:  
```js
function digui(num) {
  if (num === 0) {
    return 1
  } else {
    return num * arguments.callee(num - 1) //有多层函数时,arguments.callee该语句本身所在函数
  }
}
digui(5)  // 120
  
//callee多层函数例子如下:
function digui(num){
    var x = function(xx){console.log(arguments.callee)}
    x()
}
digui(5) //内层的函数.ƒ (xx){console.log(arguments.callee)}  
```

### 闭包. 值得详细探讨
#### 闭包是什么?
MDN: 函数和其词法环境的引用结合在一起,构成闭包.可以在函数内部访问到外部的词法作用域.
#### 闭包的基础
1. js中的函数可以像变量一样返回  
2. 词法作用域

#### Exampl-001 :
```js
var name = "outer"
function makeFunc() {
    var name = "Mozilla";
    function displayName() {
        console.log(name);     //这里如果加了this.返回的就是 "outer"了
    }
    return displayName;
}
var myFunc = makeFunc();
myFunc();
```
> 解析: myFunc 是执行 makeFunc 时,返回的 displayName 函数实例的引用,displayName 的实例维持了一个对它的词法环境（变量 name 存在于其中）的引用。因此，当 myFunc 被调用时，变量 name 仍然可用，其值 Mozilla 就被传递到console.log中。  

##### Exampl-002:
下面是一个更有意思的示例 — 一个 makeAdder 函数：  
```js
function makeAdder(x) {
  return function(y) {
    return x + y;
  };
}

var add5 = makeAdder(5);
var add10 = makeAdder(10);

console.log(add5(2));  // 7
console.log(add10(2)); // 12
```
在这个示例中，我们定义了 makeAdder(x) 函数，它接受一个参数 x ，并返回一个新的函数。返回的函数接受一个参数 y，并返回x+y的值。  
从本质上讲，makeAdder 是一个函数工厂 — 他创建了将指定的值和它的参数相加求和的函数。在上面的示例中，我们使用函数工厂创建了两个新函数 — 一个将   其参数和 5 求和，另一个和 10 求和。
add5 和 add10 都是闭包。它们共享相同的函数定义，但是保存了不同的词法环境。在 add5 的环境中，x 为 5。而在 add10 中，x 则为 10。
